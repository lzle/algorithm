## 红黑树

`红黑树`的英文是`“Red-Black Tree”`，简称 `R-B Tree`。它是一种不严格的`平衡二叉查找树`。

`平衡二叉查找树`这类数据结构的初衷是，解决普通`二叉查找树`在频繁的`插入`、`删除`等动态更新的情况下，
出现`时间复杂度退化`的问题。

`平衡二叉查找树`中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，
`不要出现左子树很高`、`右子树很矮`的情况。这样就能让整棵树的高度相对来说低一些，
相应的`插入`、`删除`、`查找`等操作的`效率高`一些。

最先被发明的`平衡二叉查找树`是 `AVL` 树，它严格符合`平衡二叉查找树`的定义，
即任何节点的左右子树`高度`相差不超过 `1`，是一种`高度平衡`的`二叉查找树`。

`红黑树`的要求：

* `根节点是黑色的；`
* `每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；`
* `任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；`
* `每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；`

图例：
<img src="https://static001.geekbang.org/resource/image/90/9a/903ee0dcb62bce2f5b47819541f9069a.jpg" width=500>

`红黑树`是一种`近似平横`的平衡的`二叉查找树`，“平衡”的意思可以等价为性能不退化。“近似平衡”就等价为性能`不会退化得太严重`。

#### 时间复杂度分析

如果我们将红色节点从红黑树中去掉，那单纯包含黑色节点的红黑树的高度是多少呢？

<img src="https://static001.geekbang.org/resource/image/7e/ed/7e6ecc308fe44120f30de809822215ed.jpg" width=500>

如图所示，`红黑树`变成了`四叉树`，根据`红黑树`第四条规则，`每个节点到叶子节点包含数目相同的黑色节点`，
也就是说根节点到任意叶节点的`高度是一致`的！！把四叉树取出一些节点放到叶节点位置，会变成`完全二叉树`。
高度为 `O(log2n)`,而只有黑色节点的四叉树的高度是小于等于 `O(log2n)`。

把红色节点再添加回去，红色节点只能穿插在黑色节点当中，最长路径最大扩大一倍，即`红黑树`的高度小于等于 `2O(log2n)`。
`红黑树`的高度只比高度平衡的 `AVL` 树的高度 `（log2n）`仅仅大了一倍。

`红黑树`的高度近似 `log2n`，所以它是近似平衡，`插入`、`删除`、`查找`操作的`时间复杂度`都是 `O(logn)`。

#### `AVL 树`对比 `红黑树`

`AVL 树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利就有弊，AVL 树为了维持这种高度的平衡，
就要付出更多的代价。每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，
使用 AVL 树的代价就有点高了。`

`红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比 AVL 树要低。所以，
红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，
为了支撑这种工业级的应用，我们更倾向于这种性能稳定的平衡二叉查找树。`

## 思考

1） `如何实现一个红黑树？`