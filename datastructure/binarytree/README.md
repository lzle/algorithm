## 树

什么是树？

> 树是一种非线性数据结构，由节点组成。节点又分为根节点、叶节点、节点。

概念：节点高度、深度、层数。

<img src="https://static001.geekbang.org/resource/image/50/b4/50f89510ad1f7570791dd12f4e9adeb4.jpg" width=500>

## 二叉树

二叉树在树的基础上，每个节点最多只有两个子节点。

> 满二叉树: 除叶子节点外，每个节点都有两个子节点的二叉树。

> 完全二叉树:最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大。

二叉树有两种存储方式：

`链式存储法`

<img src="https://static001.geekbang.org/resource/image/12/8e/12cd11b2432ed7c4dfc9a2053cb70b8e.jpg" width=500>

`顺序存储法`

<img src="https://static001.geekbang.org/resource/image/14/30/14eaa820cb89a17a7303e8847a412330.jpg" width=500>

`完全二叉树`，那用`数组存储`无疑是最`节省内存`的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的`左右子节点的指针`。这也是为什么完全二叉树会单独拎出来的原因，也是为什么完全二叉树要求最后一层的子节点都靠左的原因。

`堆`其实就是一种`完全二叉树`，最常用的存储方式就是数组。

## 二叉树的遍历

经典的三种方法：

* `前序遍历，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。`
* `中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。`
* `后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。`

二叉树遍历的时间复杂度是 `O(n)`。[前序、中序、后序遍历](traverse/README.md)

## 二叉查找树

二叉查找树是为了实现快速查找而生的。在树中的任意一个节点，其`左子树`中的每个节点的值，
都要`小于`这个节点的值，而`右子树`节点的值都`大于`这个节点的值。

特点：`支持动态数据集合的快速插入、删除、查找操作`。

二叉查找树还有重要的特性，就是中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效。

#### 查找操作

先取`根节点`，如果它`等于`我们要查找的数据，那就返回。如果要查找的数据比根节点的值`小`，那就在`左子树`中递归查找；
如果要查找的数据比根节点的值`大`，那就在`右子树`中递归查找。

#### 插入操作

插入操作与查找操作类似，先查找，然后插入。

数据比节点的数据`大`，并且节点的`右子树`为`空`；数据比节点的数据`小`，并且节点的`左子树`为`空`。

#### 删除操作

删除操作，稍微复杂了一点，有三种情况：

* `第一种情况，如果要删除的节点没有子节点，直接删除，节点 55。`

* `第二种情况，要删除的节点只有一个子节点，子节点替换删除结点的位置，节点 13`

* `第三种情况，删除的节点左右子节点都有，找到节点的右子树的最小节点替换节点。节点 18`

<img src="https://static001.geekbang.org/resource/image/29/2c/299c615bc2e00dc32225f4d9e3490e2c.jpg" width=500>

#### 重复数据

在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的`右子树`，也就是说，
把这个新插入的数据当作`大于`这个节点的值来处理。

#### 时间复杂度

时间复杂度其实都跟树的高度成正比，也就是 `O(height)`。

## 思考 🤔

1）`给定一组数据，比如 1，3，5，6，9，10。你来算算，可以构建出多少种不同的二叉树？`

2）`我们讲了三种二叉树的遍历方式，前、中、后序。实际上，还有另外一种遍历方式，也就是按层遍历，你知道如何实现吗？`

3）`二叉树相对于散列表的优势?`

4）`实现一个二叉查找树，并且支持插入、删除、查找操作`

5）`实现查找二叉查找树中某个节点的后继、前驱节点`

6）`实现二叉树前、中、后序以及按层遍历`

## 解答

1） `既然是数组了，说明是完全二叉树，应该有n的阶乘个组合。`

2）`二叉树按层遍历，可以看作以根结点为起点，图的广度优先遍历的问题。`

3） `二树优势`

* `二叉树查找树可以中序遍历有序输出，散列表需要排序操作。`

* `散列表有冲突，性能不稳定。平衡查找二叉树性能稳定。`

* `散列表实现复杂，需要考虑散列函数的设计、冲突解决办法、扩容、缩容等。`

* `尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小。`
