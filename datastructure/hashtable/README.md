# 散列表

散列表用的就是数组支持按照下标访问时间复杂度是 O(1) 的特性。
通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。

散列函数需要对 `key` 值进行计算得到散列值，作为数组的下标。我们知道哈希
算法无法避免的一个问题就是散列冲突。散列表是如何解决冲突的？

两种解决办法：`开放寻址法`、`链表法`

#### 开放寻址法

当遇到散列冲突时，重新探测一个空闲地址，将其插入。比较简单的方法是 `线性探测` ，
如果位置被占用，从当前位置开始，依次向后查找，直到找到空闲位置。

查找时与插入时操作一致，也是通过线性探测的方法。但是删除时，有区别，
可以将删除的元素，特殊标记为 `deleted` 而不真正的删除。当线性探测查找的时候，
遇到标记为 `deleted` 的空间，并不是停下来，而是继续往下探测。

对于开放寻址冲突解决方法，除了线性探测方法之外，还有另外两种比较经典的探测方法，`二次探测` 和 `双重散列`。

提高散列表的操作效率，减少散列冲突，需要动态扩容散列表的槽位，降低装载因子的值。

`散列表的装载因子=填入表中的元素个数/散列表的长度`

#### 链表法

链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。

<img src="https://static001.geekbang.org/resource/image/a4/7f/a4b77d593e4cb76acb2b0689294ec17f.jpg" width=500>

插入的时间复杂度是 `O(1)`。查找或删除操作与链表的长度成正比 `O(k)`。
对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。

#### 如何设计散列函数？

防止散列表碰撞攻击。

`有些恶意的攻击者，还有可能通过精心构造的数据,使得所有的数据经过散列函数之后，都散列到同一个槽里,
如果我们使用的是基于链表的冲突解决方法，那这个时候，散列表就会退化为链表，查询的时间复杂度就从 O(1) 急剧退化为 O(n)。`

散列函数的设计不能太复杂。

散列函数生成的值要尽可能随机并且均匀分布。

装载因子过高时进行动态扩容，避免散列冲突。

#### 避免低效扩容

当扩容时，数据需要从原来的地址从新计算哈希值再拷贝的新地址中，此时插入的时间复杂度为 `O(n)`，插入数据就会变得很慢，
甚至会无法接受。

为了解决一次性扩容耗时过多的情况，可以把旧的数据分批次拷贝到新地址中。对于查找操作，可以先去旧地址中查询，再去新地址中查询。

#### 如何选择冲突解决方案？

Java 中 `LinkedHashMap` 就采用了链表法解决冲突，`ThreadLocalMap` 是通过线性探测的开放寻址法来解决冲突。

开放寻址法:

* 数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。

* 为避免散列冲突，装载因子不能太大，浪费一定的内存空间。

链表法:

* 内存利用率高

* 链表需要存储指针，如果存储大对象`（4 个字节或者 8 个字节）`指针占用空间可以忽略。

* 链表中的结点是零散分布在内存中的，不是连续的，所以对 CPU 缓存是不友好的。

* 链表可以改造成跳表、红黑树。即便出现散列冲突，极端情况下，查找时间也只不过是 O(logn)。

* 链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表。

大部分情况下，链表法更加普适。而且，我们还可以通过将链表法中的链表改造成其他动态查找数据结构，比如红黑树，
来避免散列表时间复杂度退化成 O(n)，抵御散列碰撞攻击。
但是，对于小规模数据、装载因子不高的散列表，比较适合用开放寻址法。



#### 思考 

1）`Word` 文档中单词拼写检查功能是如何实现的？

2）Python 的 `dict` 是如何实现的？

3）Go 中的 `map` 是如何实现的？

4）假设我们有 10 万条 `URL` 访问日志，如何按照访问次数给 `URL` 排序？

5）有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？





