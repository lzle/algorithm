# 散列表

散列表用的就是数组支持按照下标访问时间复杂度是 O(1) 的特性。
通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。

散列函数需要对 `key` 值进行计算得到散列值，作为数组的下标。我们知道哈希
算法无法避免的一个问题就是散列冲突。散列表是如何解决冲突的？

两种解决办法：`开放寻址法`、`链表法`

#### 开放寻址法

当遇到散列冲突时，重新探测一个空闲地址，将其插入。比较简单的方法是 `线性探测` ，
如果位置被占用，从当前位置开始，依次向后查找，直到找到空闲位置。

查找时与插入时操作一致，也是通过线性探测的方法。但是删除时，有区别，
可以将删除的元素，特殊标记为 `deleted` 而不真正的删除。当线性探测查找的时候，
遇到标记为 `deleted` 的空间，并不是停下来，而是继续往下探测。

对于开放寻址冲突解决方法，除了线性探测方法之外，还有另外两种比较经典的探测方法，`二次探测` 和 `双重散列`。

提高散列表的操作效率，减少散列冲突，需要动态扩容散列表的槽位，降低装载因子的值。

`散列表的装载因子=填入表中的元素个数/散列表的长度`

#### 链表法

链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。

<img src="https://static001.geekbang.org/resource/image/a4/7f/a4b77d593e4cb76acb2b0689294ec17f.jpg" width=500>

插入的时间复杂度是 `O(1)`。查找或删除操作与链表的长度成正比 `O(k)`。
对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。



## 思考 

1）Word 文档中单词拼写检查功能是如何实现的？

2）Python的dict是如何实现的？

3）Go中的map是如何实现的？

4）假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？

5）有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？





