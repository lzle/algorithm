# 插入排序

将数组中的数据分为两个区间，已排序区间和未排序区间。

插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，
并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

如下图所示，左侧是已经排序好的，右侧是还未排序的。

<img src="https://static001.geekbang.org/resource/image/b6/e1/b60f61ec487358ac037bf2b6974d2de1.jpg" width=500>

插入排序的移动次数，总数固定的，等于逆序度。

为什么说移动次数就等于逆序度呢？我拿刚才的例子画了一个图表，你一看就明白了。满有序度是 n*(n-1)/2=15，初始序列的有序度是 5，
所以逆序度是 10。插入排序中，数据移动的个数总和也等于 10=3+3+4。

<img src="https://static001.geekbang.org/resource/image/fd/01/fd6582d5e5927173ee35d7cc74d9c401.jpg" width=500>


### 解答

1）冒泡排序和插入排序的时间复杂度都是 O(n2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？

插入排序与冒泡排序的逆序度一致，所以两者的元素的移动次数是一致。但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂。
冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。我们来看这段操作：

```
冒泡排序中数据的交换操作：
if (a[j] > a[j+1]) { // 交换
   int tmp = a[j];
   a[j] = a[j+1];
   a[j+1] = tmp;
   flag = true;
}

插入排序中数据的移动操作：
if (a[j] > value) {
  a[j+1] = a[j];  // 数据移动
} else {
  break;
}
```

同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，
所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。

用代码进行性能测试，随机生成 10000 个数组，每个数组中包含 200 个数据，然后在我的机器上分别用冒泡和插入排序算法来排序，
冒泡排序算法大约 700ms 才能执行完成，而插入排序只需要 100ms 左右就能搞定！
