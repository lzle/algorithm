# 线性排序

线性排序是一种时间复杂度为O(n)的排序算法：桶排序、计数排序、基数排序。

因为这些排序算法的时间复杂度是线性的，所以我们把这类排序算法叫作线性排序。

能做到线性的时间复杂度，主要原因是，这三个算法是非基于比较的排序算法，都不涉及元素之间的比较操作。

对数据源有要求。


### 桶排序

如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。
每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，
因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，
log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。

<img src="https://static001.geekbang.org/resource/image/98/ae/987564607b864255f81686829503abae.jpg" width=500>

桶排序对于排序的数据是有要求的。

首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。

其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，
有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，
如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。


### 计数排序

计数排序其实是桶排序的一种特殊情况。

当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。

例如高考分数系统的排序，分数范围为0-750之间，可以分成701个桶。

为什么这个排序算法叫“计数”排序呢？“计数”的含义来自哪里呢？

假设只有 8 个考生，分数在 0 到 5 分之间。这 8 个考生的成绩我们放在一个数组 A[8]中，它们分别是：2，5，3，0，2，3，0，3。

考生的成绩从 0 到 5 分，我们使用大小为 6 的数组 C[6]表示桶，其中下标对应`分数`。不过，C[6]内存储的并不是考生，而是对应的考生个数。

<img src="https://static001.geekbang.org/resource/image/ad/c9/adc75672ef33fa54b023a040834fcbc9.jpg" width=500>

我们对 C[6]数组顺序求和，C[6]存储的数据就变成了下面这样子。C[k]里存储小于等于分数 k 的考生个数。

<img src="https://static001.geekbang.org/resource/image/dd/1f/dd6c62b12b0dc1b3a294af0fa1ce371f.jpg" width=500>

从后到前依次扫描数组 A , 排序步骤如下

<img src="https://static001.geekbang.org/resource/image/1d/84/1d730cb17249f8e92ef5cab53ae65784.jpg" width=500>

计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。
而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。


### 基数排序

基数排序按照每一位进行排序，例如手机号码。排序思想如下

<img src="https://static001.geekbang.org/resource/image/df/0c/df0cdbb73bd19a2d69a52c54d8b9fc0c.jpg" width=500>

根据每一位来排序，我们可以用刚讲过的桶排序或者计数排序，它们的时间复杂度可以做到 O(n)。如果要排序的数据有 k 位，
那我们就需要 k 次桶排序或者计数排序，总的时间复杂度是 O(k*n)。当 k 不大的时候，比如手机号码排序的例子，
k 最大就是 11，所以基数排序的时间复杂度就近似于 O(n)。

假如排序的数据不是等长的，可以根据补位进行补齐。

基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，
如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，
要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。

### 问题

1）如何根据年龄给 100 万用户排序？


### 解答

1） 我们可以遍历这 100 万用户，根据年龄将其划分到这 120 个桶里，然后依次顺序遍历这 120 个桶中的元素。